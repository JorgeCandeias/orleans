//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Orleans.Hosting
{
    public static partial class ScheduledJobsExtensions
    {
        public static void AddScheduledJobs(this Microsoft.Extensions.DependencyInjection.IServiceCollection services) { }

        public static ISiloBuilder AddScheduledJobs(this ISiloBuilder builder) { throw null; }

        public static ISiloBuilder UseInMemoryScheduledJobs(this ISiloBuilder builder) { throw null; }
    }

    public sealed partial class ScheduledJobsOptions
    {
        public int MaxConcurrentJobsPerSilo { get { throw null; } set { } }

        public System.TimeSpan ShardActivationBufferPeriod { get { throw null; } set { } }

        public System.TimeSpan ShardDuration { get { throw null; } set { } }

        public System.Func<ScheduledJobs.IScheduledJobContext, System.Exception, System.DateTimeOffset?> ShouldRetry { get { throw null; } set { } }
    }

    public sealed partial class ScheduledJobsOptionsValidator : IConfigurationValidator
    {
        public ScheduledJobsOptionsValidator(Microsoft.Extensions.Logging.ILogger<ScheduledJobsOptionsValidator> logger, Microsoft.Extensions.Options.IOptions<ScheduledJobsOptions> options) { }

        public void ValidateConfiguration() { }
    }
}

namespace Orleans.ScheduledJobs
{
    public partial interface IJobShard : System.IAsyncDisposable
    {
        System.DateTimeOffset EndTime { get; }

        string Id { get; }

        bool IsAddingCompleted { get; }

        System.Collections.Generic.IDictionary<string, string>? Metadata { get; }

        System.DateTimeOffset StartTime { get; }

        System.Collections.Generic.IAsyncEnumerable<IScheduledJobContext> ConsumeScheduledJobsAsync();
        System.Threading.Tasks.ValueTask<int> GetJobCountAsync();
        System.Threading.Tasks.Task MarkAsCompleteAsync(System.Threading.CancellationToken cancellationToken);
        System.Threading.Tasks.Task<bool> RemoveJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);
        System.Threading.Tasks.Task RetryJobLaterAsync(IScheduledJobContext jobContext, System.DateTimeOffset newDueTime, System.Threading.CancellationToken cancellationToken);
        System.Threading.Tasks.Task<ScheduledJob?> TryScheduleJobAsync(Runtime.GrainId target, string jobName, System.DateTimeOffset dueTime, System.Collections.Generic.IReadOnlyDictionary<string, string>? metadata, System.Threading.CancellationToken cancellationToken);
    }

    public partial interface ILocalScheduledJobManager
    {
        System.Threading.Tasks.Task<ScheduledJob> ScheduleJobAsync(Runtime.GrainId target, string jobName, System.DateTimeOffset dueTime, System.Collections.Generic.IReadOnlyDictionary<string, string>? metadata, System.Threading.CancellationToken cancellationToken);
        System.Threading.Tasks.Task<bool> TryCancelScheduledJobAsync(ScheduledJob job, System.Threading.CancellationToken cancellationToken);
    }

    public partial interface IScheduledJobContext
    {
        int DequeueCount { get; }

        ScheduledJob Job { get; }

        string RunId { get; }
    }

    public partial interface IScheduledJobHandler
    {
        System.Threading.Tasks.Task ExecuteJobAsync(IScheduledJobContext context, System.Threading.CancellationToken cancellationToken);
    }

    public abstract partial class JobShard : IJobShard, System.IAsyncDisposable
    {
        protected JobShard(string id, System.DateTimeOffset startTime, System.DateTimeOffset endTime) { }

        public System.DateTimeOffset EndTime { get { throw null; } protected set { } }

        public string Id { get { throw null; } protected set { } }

        public bool IsAddingCompleted { get { throw null; } protected set { } }

        public System.Collections.Generic.IDictionary<string, string>? Metadata { get { throw null; } protected set { } }

        public System.DateTimeOffset StartTime { get { throw null; } protected set { } }

        public System.Collections.Generic.IAsyncEnumerable<IScheduledJobContext> ConsumeScheduledJobsAsync() { throw null; }

        public virtual System.Threading.Tasks.ValueTask DisposeAsync() { throw null; }

        protected void EnqueueJob(ScheduledJob job, int dequeueCount) { }

        public System.Threading.Tasks.ValueTask<int> GetJobCountAsync() { throw null; }

        public System.Threading.Tasks.Task MarkAsCompleteAsync(System.Threading.CancellationToken cancellationToken) { throw null; }

        protected abstract System.Threading.Tasks.Task PersistAddJobAsync(string jobId, string jobName, System.DateTimeOffset dueTime, Runtime.GrainId target, System.Collections.Generic.IReadOnlyDictionary<string, string>? metadata, System.Threading.CancellationToken cancellationToken);
        protected abstract System.Threading.Tasks.Task PersistRemoveJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);
        protected abstract System.Threading.Tasks.Task PersistRetryJobAsync(string jobId, System.DateTimeOffset newDueTime, System.Threading.CancellationToken cancellationToken);
        public System.Threading.Tasks.Task<bool> RemoveJobAsync(string jobId, System.Threading.CancellationToken cancellationToken) { throw null; }

        public System.Threading.Tasks.Task RetryJobLaterAsync(IScheduledJobContext jobContext, System.DateTimeOffset newDueTime, System.Threading.CancellationToken cancellationToken) { throw null; }

        public System.Threading.Tasks.Task<ScheduledJob?> TryScheduleJobAsync(Runtime.GrainId target, string jobName, System.DateTimeOffset dueTime, System.Collections.Generic.IReadOnlyDictionary<string, string>? metadata, System.Threading.CancellationToken cancellationToken) { throw null; }
    }

    public abstract partial class JobShardManager
    {
        protected JobShardManager(Runtime.SiloAddress siloAddress) { }

        protected Runtime.SiloAddress SiloAddress { get { throw null; } }

        public abstract System.Threading.Tasks.Task<System.Collections.Generic.List<IJobShard>> AssignJobShardsAsync(System.DateTimeOffset maxDueTime, System.Threading.CancellationToken cancellationToken);
        public abstract System.Threading.Tasks.Task<IJobShard> CreateShardAsync(System.DateTimeOffset minDueTime, System.DateTimeOffset maxDueTime, System.Collections.Generic.IDictionary<string, string> metadata, System.Threading.CancellationToken cancellationToken);
        public abstract System.Threading.Tasks.Task UnregisterShardAsync(IJobShard shard, System.Threading.CancellationToken cancellationToken);
    }

    [GenerateSerializer]
    [Alias("Orleans.ScheduledJobs.ScheduledJob")]
    public sealed partial class ScheduledJob
    {
        [Id(2)]
        public System.DateTimeOffset DueTime { get { throw null; } init { } }

        [Id(0)]
        public required string Id { get { throw null; } init { } }

        [Id(5)]
        public System.Collections.Generic.IReadOnlyDictionary<string, string>? Metadata { get { throw null; } init { } }

        [Id(1)]
        public required string Name { get { throw null; } init { } }

        [Id(4)]
        public required string ShardId { get { throw null; } init { } }

        [Id(3)]
        public Runtime.GrainId TargetGrainId { get { throw null; } init { } }
    }
}

namespace OrleansCodeGen.Orleans.ScheduledJobs
{
    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Codec_ScheduledJob : global::Orleans.Serialization.Codecs.IFieldCodec<global::Orleans.ScheduledJobs.ScheduledJob>, global::Orleans.Serialization.Codecs.IFieldCodec
    {
        public Codec_ScheduledJob(global::Orleans.Serialization.Activators.IActivator<global::Orleans.ScheduledJobs.ScheduledJob> _activator, global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public void Deserialize<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.ScheduledJobs.ScheduledJob instance) { }

        public global::Orleans.ScheduledJobs.ScheduledJob ReadValue<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Serialization.WireProtocol.Field field) { throw null; }

        public void Serialize<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, global::Orleans.ScheduledJobs.ScheduledJob instance)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }

        public void WriteField<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, uint fieldIdDelta, System.Type expectedType, global::Orleans.ScheduledJobs.ScheduledJob value)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Copier_ScheduledJob : global::Orleans.Serialization.Cloning.IDeepCopier<global::Orleans.ScheduledJobs.ScheduledJob>, global::Orleans.Serialization.Cloning.IDeepCopier
    {
        public Copier_ScheduledJob(global::Orleans.Serialization.Activators.IActivator<global::Orleans.ScheduledJobs.ScheduledJob> _activator, global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public global::Orleans.ScheduledJobs.ScheduledJob DeepCopy(global::Orleans.ScheduledJobs.ScheduledJob original, global::Orleans.Serialization.Cloning.CopyContext context) { throw null; }
    }
}